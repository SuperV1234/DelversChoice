\documentclass[12pt]{report}

\usepackage{verbatim}
\usepackage{fullpage}
\usepackage{etoolbox}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{pdftexcmds}
\usepackage{minted}
\usepackage{fixltx2e}
\usepackage{calc}
\usepackage{doxygen}
\usepackage[export]{adjustbox} % also loads graphicx
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\usepackage{multicol}
\usepackage{multirow}
\PassOptionsToPackage{warn}{textcomp}
\usepackage{textcomp}
\usepackage[nointegrals]{wasysym}
\usepackage[table]{xcolor}

% Font selection

\renewcommand{\DoxyLabelFont}{}
\newcommand{\+}{\discretionary{\mbox{\scriptsize$\hookleftarrow$}}{}{}}

% Page & text layout
\usepackage{geometry}



% Headers & footers
\usepackage{fancyhdr}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\chaptermark}[1]{%
  \markboth{#1}{}%
}
\renewcommand{\sectionmark}[1]{%
  \markright{\thesection\ #1}%
}

% Indices & bibliography
\usepackage{natbib}
\usepackage[titles]{tocloft}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{5}
\makeindex

% Hyperlinks (required, but should be loaded last)
\usepackage{ifpdf}
\hypersetup{%
  colorlinks=false,%
  linkcolor=blue,%
  citecolor=blue,%
  unicode%
}

% Custom commands
\newcommand{\clearemptydoublepage}{%
  \newpage{\pagestyle{empty}\cleardoublepage}%
}


\graphicspath{ {res/} }
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\renewcommand\emph{\textbf}
\renewcommand{\baselinestretch}{1.1}

\newcommand{\printSQLtest}[1]
{
    \inputminted[linenos, breaklines, breakbytoken, tabsize=4, fontsize=\footnotesize]{mysql}{#1}
}

\newcommand{\printPHPImpl}[1]
{
    \inputminted[linenos, breaklines, breakbytoken, tabsize=4, fontsize=\footnotesize]{php}{#1}
}

\newcommand{\printPHP}[1]
{
    \printPHP{../www/php/#1}
}

\newcommand{\printSQLTablepage}[2]
{    
    \subsection{#2}
    \subsubsection{Code}
    \printSQLtest{../sql/parts/#1}
    \subsubsection{Explanation}
}

\begin{document}



\begin{titlepage}

    \center

    \textsc{\LARGE Universita' degli Studi di Messina}\\[0.1cm]
    \textsc{\Large Dipartimento di Matematica e Informatica}\\[0.5cm]
    \textsc{\Large Programming II project}\\[0.5cm]

    \HRule \\[0.4cm]
    { \huge \bfseries NetLayer}\\[0.1cm]

    {\large 11 June 2015}
    \HRule \\[1.5cm]

    \begin{minipage}{0.4\textwidth}
    \begin{flushleft} \large
    \emph{Authors:}\\
    Vittorio \textsc{Romeo}
    \end{flushleft}
    \end{minipage}
    ~
    \begin{minipage}{0.4\textwidth}
    \begin{flushright} \large
    \emph{Professors:} \\
    Massimo \textsc{Villari}


    \end{flushright}
    \end{minipage}\\[4cm]

    \vfill


    \begin{minipage}{\linewidth}
        \centering
        \begin{minipage}{0.35\linewidth}
            \begin{figure}[H]
                \center
                \includegraphics[width=2cm, height=2cm]{logovee}

                \url{http://vittorioromeo.info}
            \end{figure}
        \end{minipage}
        \hspace{0.27\linewidth}
        \begin{minipage}{0.35\linewidth}
            \begin{figure}[H]
                \center
                \includegraphics[width=2cm, height=2cm]{logounime}

                \url{http://unime.it}
            \end{figure}
        \end{minipage}
    \end{minipage}\\[3cm]
\end{titlepage}



\pagenumbering{gobble}
\newcommand{\atoc}[1]{\addtocontents{toc}{#1\par}}
\renewcommand{\thesection}{\arabic{section}.}
\tableofcontents
\newpage
\pagenumbering{arabic}




\part{Project specifications}

    The following part of the document describes the project and its design/development process without exploring its implementation details.

    The part begins with a synthesis of the \emph{client request}. After a careful analysis of the request, a \emph{Software Requirements Specification} (SRS) was written.

    Writing a correct and informative SRS is of utmost importance to achieve an high-quality final product and ensuring the development process goes smoothly.

    The SRS will cover the following points in depth:

    \begin{itemize}
        \item \emph{Scope and purpose}.
        \item \emph{Feature and functions}.
        \item \emph{External interface requirements}.
        \item \emph{Functional requirements}.
        \item \emph{Example use cases}.
        \item \emph{Non-functional requirements}.
        \item \emph{Analysis models}.
    \end{itemize}

    \chapter{Client request}

        The client requests the design and implementation of an \emph{open-source multi-purpose C++14 networking library}.

        The library must allow the client to develop its own \emph{server-client} architectures and applications with ease, while still being performant and allowing low-level operations if required.

        The client intends to use the library as a basis for the networking layer in applications belonging to different domains, ranging from \emph{chat web applications} to \emph{real-time games and simulations}.

        The library must fulfill the following requirements:

        \begin{itemize}
            \item The library must be written in \emph{modern C++14}, making use of the latest features to improve performance, readability and flexibility.

            \item The library must target \emph{UNIX} systems, \emph{Windows} and \emph{MacOS}.

            \item The library must have a \emph{layered architecture}, allowing developers using it to go as low-level/high-level they desire.

            \item The library must deal with \emph{byte serialization} of native and user-defined classes. Nested serializable data structures must be supported.

            \item The library must provide a generic \emph{tunnel abstraction} that represents a network entity providing and receiving data. A UDP socket tunnel implementation must be provided with the library.

            \item The library must provide an high-level abstraction for \emph{server-client} multithreaded architectures, allowing applications to asynchronously interact with any number of sockets and conveniently handle received packets via function dispatching.

            \item The library must provide metaprogramming facilities to generate and bind packet types at compile-time, allowing performant code generation for serialization/deserialization and communication.

            \item The library must be released under an \emph{open-source} license and promote collaboration and external contributions.
        \end{itemize}

        The client intends using the requested library \emph{to build platforms} for various projects, both for internal company usage and public usage.

        It is imperative for the library to be easily integrable with existing legacy system, such as architectures depending on relational databases.

        For ease of development and deployment, the client requested the library to be optionally usable in \emph{header-only} mode and compatibility with the \emph{CMake} build system.

        The abstraction provided by the library must work asynchronously by default, but an option to use blocking IO must be present.

    \chapter{Software Requirements Specification}


        \section{Introduction}

            \subsection{Software engineering}

                \emph{Software engineering} is the study and an application of engineering to the design, development, and maintenance of software.

                The Bureau of Labor Statistics' definition is Research, design, develop, and test operating systems-level software, compilers, and network distribution software for medical, industrial, military, communications, aerospace, business, scientific, and general computing applications.

                Typical formal definitions of software engineering are:

                \begin{itemize}
                    \item The systematic application of scientific and technological knowledge, methods, and experience to the design, implementation, testing, and documentation of software.
                    \item The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.
                    \item An engineering discipline that is concerned with all aspects of software production.
                    \item The establishment and use of sound engineering principles in order to economically obtain software that is reliable and works efficiently on real machines.
                \end{itemize}

                \subsubsection{Background}

                    The term \emph{software engineering} goes back to the '60s, when more complex programs started to be developed by teams composed by experts.

                    There was a radical transformation of software: from \emph{artisan product} to \emph{industrial product}.

                    A software engineer needs to be a good programmer, an algorithm and data structures expert with good knowledge of one or more programming languages.

                    He needs to know various design processes, must have the ability to convert generic requirements in well-detailed and accurate specifications, and needs to be able to communicate with the end-user in a language comprehensible to him comprehensible.

                    Software engineering, is, however, a discipline that's still evolving. There still are no definitive standards for the software development process.

                    Compared to traditional engineering, which is based upon mathematics and solid methods and where well-defined standards need to be followed, software engineering is greatly dependent on personal experience rather than mathematical tools.

                    Here's a brief history of software engineering:

                    \begin{itemize}
                        \item \emph{1950s}: Computers start to be used extensively in business applications.
                        \item \emph{1960s}: The first software product is marketed.

                        IBM announces its unbundling in June 1969.
                        \item \emph{1970s}: Software products are now regularly bought by normal users.

                        The software development industry grows rapidly despite the lack of financing.

                        The first software houses begin to emerge.
                    \end{itemize}

                \subsubsection{Differences with programming}

                    \begin{itemize}
                        \item A programmer writes a complete program.
                        \item A software engineer writes a software component that will be combined with components written by other software engineers to build a system.
                    \end{itemize}

                    \begin{itemize}
                        \item Programming is primarily a personal activity.
                        \item Software engineering is essentially a team activity.
                    \end{itemize}

                    \begin{itemize}
                        \item Programming is just one aspect of software development.
                        \item Large software systems must be developed similar to other engineering practices.
                    \end{itemize}

            \subsection{SRS}

                This \emph{Software Requirements Specification} (SRS) chapter contains all the information needed by software engineers and project managers to design and implement the requested forum creation/management framework.

                The SRS was written following the \emph{Institute of Electrical and Electronics Engineers} (IEEE) guidelines on SRS creation.

            \subsection{Purpose}
                The SRS chapter is contained in the \emph{non-technical} part of the thesis.

                Its purpose is providing a \emph{comprehensive description} of the objective and environment for the software under development.

                The SRS fully describes \emph{what the software will do} and \emph{how it will be expected to perform}.

            \subsection{Scope}

                \subsubsection{Identity}
                    The software that will be designed and produced will be called \emph{NetLayer}.

                \subsubsection{Feature extents}

                    The complete product will:

                    \begin{itemize}
                        \item Provide a library for the \emph{development of multi-purpose network applications and architectures}.
                        \item Provide abstractions for all the major  \emph{operating systems' networking layer}.
                        \item Provide an extensible and flexible  \emph{data serialization} module for primitive and user-defined classes.
                    \end{itemize}

                    NetLayer, however, will not be a complete framework for the development of applications. Every part of an application that does not deal with networking issues will not be covered by the product.

                \subsubsection{Benefits and objectives}

                    Development using NetLayer will give companies and individuals several benefits over \"from-scratch\" development.

                    \begin{itemize}
                        \item Usage of NetLayer will provide access to an \emph{easy-to-integrate} and \emph{easy-to-use} networking library.
                        \item Development and testing time will be \emph{significantly reduced}.
                        \item Code making use of the library will be \emph{modern, efficient and readable} thanks to C++14 features and abstractions.
                    \end{itemize}

        \section{General description}
            \subsection{Product perspective and functions}
                The product shares many basic aspects and features with existing networking libraries, improving upon them in the following ways:

                \begin{itemize}
                    \item A layer-based architecture allows developers to make use of both low-level constructs and operations and high-level abstractions in the same application.
                    \item The library will optionally allow developers to use a programming style similar to \emph{functional programming}, making use of callbacks and first-class functions to deal with packet management and function dispatching.
                    \item
                \end{itemize}

            \subsection{User characteristics}
                NetLayer is targeted towards modern C++ developers experienced with C++11 and C++14 features. The library makes heavy use of modern metaprogramming paradigms and techniques - unfamiliar users will not be able to make full use of the library.

                A \"more functional\" interface is provided where possible, allowing users to use convenient abstractions for data serialization functions and networking functions.

                Familiarity with multithreading and synchronous computation is also required to use the library.

        \section{Glossary}

            The following list contains all the main elements that compose the architecture of NetLayer.

            \begin{itemize}
                \item \emph{Packet Buffer}: dynamically resizable buffer that can store and provide serialized generic data.
                \item \emph{Address}: union of an IP address and a port.
                \item \emph{Payload}: abstraction consisting of an Address and PcktBuf. It can be sent to and received by Tunnel instances.
                \item \emph{Tunnel}: abstraction of a Payload provider/receiver. The default Tunnel is an UDP socket.
                \item \emph{Thread Safe Queue}: a lock-based thread safe queue that supports concurrent enqueueing and dequeueing.
                \item \emph{Managed Packet Buffer}: abstraction consisting of a Thread Safe Queue and a reference to a Tunnel. It can be either a \emph{Managed Receive Buffer}, which enqueues received data from the tunnel, or a \emph{Managed Send Buffer}, which enqueues data that will be sent through the tunnel.
                \item \emph{Managed Host}: union of an Address, a Tunnel, a Managed Receive Buffer and a Managed Send Buffer. Represents a network entity capable of sending and receiving data through a tunnel.
                \item \emph{Serializable}: abstraction over a tuple of generic types that automatically allows the user to serialize and deserialize data. Serializable packets can also be nested and contain dynamically-resizable data structures.
                \item \emph{Packet Bind}: compile-time bind of a Serializable to a Packet type. Used to generate a dispatch table.
                \item \emph{Dispatch Table}: compile-time function table that binds a function to specific packet binds. Used to handle received packets.
                \item \emph{Context Managed Host}: union of a managed host and a dispatch table.
            \end{itemize}

        \section{Specific requirements}

            \subsection{External interface requirements}

                \emph{External interface requirements} identify and document the interfaces to other systems and external entities within the project scope.

                \subsubsection{User interfaces}
                    The product will not provide any graphical user interface. The users of the library will be able to access its functions and types using C++14.

                \subsubsection{Software interfaces}
                    The \emph{open-source policy} of NetLayer will allow its users to expand or improve existing functionality and to interact with other existing technologies.

            \subsection{Functional requirements}
                In software engineering, a \emph{functional requirement} defines a function of a system and its components.

                Functional requirements may be \emph{calculations}, \emph{technical details}, \emph{data manipulation and processing} and other specific functionality that define what a system is supposed to accomplish.

                Behavioral requirements describing all the cases where the system uses the functional requirements are captured in \emph{use cases}.

                \subsubsection{Packet management}
                    \begin{itemize}
                        \item \emph{Payloads and thread-safe queue}: an abstraction consisting of an address and data is provided, along with a thread-safe queue that is used for sending/receiving data to/from the network in managed buffers.
                        \item \emph{Managed buffers}: payloads will be enqueued and dequeued in managed buffers, that allow to asynchronously access the contents of their queue.
                    \end{itemize}

                    
                    \begin{figure}[!htb]
                    \caption{Managed buffer example diagram.}
                    \centering
                    \includegraphics[width=0.85\textwidth]{d/other/managedbuf.png}
                    \end{figure}

                 \subsubsection{Data serialization}
                    \begin{itemize}
                        \item \emph{Fundamental types}: fundamental C++ type serialization will automatically be provided by the library.
                        \item \emph{Common C++ classes}: serialization for commonly used C++ classes, such as \mintinline{cpp}{std::vector} and \mintinline{cpp}{std::array}, is provided by default.
                        \item \emph{Extensible serialization}: library user will be able to extend the serialization system with their own types, using simple class inheritance or macros for convenience.
                    \end{itemize}

                    
                    \begin{figure}[!htb]
                    \caption{Automatic serialization hierarchy.}
                    \centering
                    \includegraphics[width=1\textwidth]{d/other/serialization.png}
                    \end{figure}

                  \subsubsection{Tunnel management}
                    \begin{itemize}
                        \item \emph{Default tunnel: UDP}: a tunnel implementation, wrapping an UDP socket, is provided by default.
                        \item \emph{Default tunnel: mock}: a mock tunnel, for unit-testing purposes, is provided by default.
                        \item \emph{Tunnel interface}: an extensible tunnel interface is provided, allowing the users of the library to implement their own network tunnels.
                    \end{itemize}

                    \begin{figure}[!htb]
                    \caption{Tunnel example diagram.}
                    \centering
                    \includegraphics[width=0.85\textwidth]{d/other/tunnel.png}
                    \end{figure}

                \subsubsection{Context binding}
                 \begin{itemize}
                        \item \emph{Managed hosts}: abstraction consisting of a send managed buffer and a receive managed buffer. Allows the user to add processing threads and to poll the buffers for received data.
                        \item \emph{Dispatch table}: an extensible table, configurable at compile-time, is provided to allow the user to define functions which will automatically handle specific packet types.
                        \item \emph{Context host}: union of a managed host and a dispatch table. Provides a convenient interface to quickly develop a server/client architecture capable of sending and receiving payloads.
                    \end{itemize}

                \begin{figure}[!htb]
                    \caption{Context host diagram.}
                    \centering
                    \includegraphics[width=0.85\textwidth]{d/other/ctxhost.png}
                    \end{figure}

            \newpage

            \subsection{Example use cases}
                In software and systems engineering, a \emph{use case} is a list of steps, typically defining interactions between one or more actors and a system, to achieve a goal.

                In the following examples, we'll cover possible use cases for two different developer types using NetLayer:

                \begin{itemize}
                            \item \emph{Networking layer developer}: developer managing packet types, tunnel types and their bindings.
                            \item \emph{Application layer developer}: developer managing application logic, making use of existing NetLayer bindings.
                        \end{itemize}

                \subsubsection{Defining tunnel types}
                    
                    Defining tunnel types is a low-level operation done by networking layer developers. It allows NetLayer users to implement their own protocols or mock payload providers/receivers.

                    \paragraph{Actors}
                        \begin{itemize}
                            \item Networking layer developer.
                            \item NetLayer library.
                        \end{itemize}

                    \paragraph{Pre-conditions}
                        \begin{itemize}
                            \item NetLayer was correctly included.
                        \end{itemize}

                    \paragraph{Post-conditions}
                        \begin{itemize}
                            \item An usable tunnel type for context hosts or manual payload management was defined.
                        \end{itemize}

                    \begin{figure}[H]
                    \caption{Defining tunnel types - use case diagram.}
                    \centering
                    \includegraphics[width=0.65\textwidth]{d/uc/def_tunnels.png}
                    \end{figure}

                \subsubsection{Defining serializable types}
                    
                    Serializable types will be usually defined by networking layer developers and used by both types of developers. 
                    Fundamental types are automatically serializable. Tuples of fundamental types can be marked as serializable and wrapped in custom interfaces using either compile-time inheritance or helper preprocessor macros.

                    \paragraph{Actors}
                        \begin{itemize}
                            \item Networking layer developer.
                            \item Application layer developer.
                            \item NetLayer library.
                        \end{itemize}

                    \paragraph{Pre-conditions}
                        \begin{itemize}
                            \item NetLayer was correctly included.
                        \end{itemize}

                    \paragraph{Post-conditions}
                        \begin{itemize}
                            \item Any number of serializable types were defined.
                            \item Defined types can be sent/received through tunnels.
                            \item Defined types can be used as normal C++ types.
                        \end{itemize}

                    \begin{figure}[H]
                    \caption{Defining serializable types - use case diagram.}
                    \centering
                    \includegraphics[width=0.65\textwidth]{d/uc/def_serializable_t.png}
                    \end{figure}


                \subsubsection{Binding types to dispatch table}
                    
                    The creation and management of a dispatch table is usually handled by networking layer developers. They will define and bind all packet types that can be received and sent by the application.

                    \paragraph{Actors}
                        \begin{itemize}
                            \item Networking layer developer.
                            \item NetLayer library.
                        \end{itemize}

                    \paragraph{Pre-conditions}
                        \begin{itemize}
                            \item NetLayer was correctly included.
                        \end{itemize}

                    \paragraph{Post-conditions}
                        \begin{itemize}
                            \item A dispatch table was defined.
                            \item Functions can now be assigned to every inbound payload type.
                        \end{itemize}

                    \begin{figure}[H]
                    \caption{Binding types to dispatch table - use case diagram.}
                    \centering
                    \includegraphics[width=0.65\textwidth]{d/uc/bind_types.png}
                    \end{figure}


                \subsubsection{Defining a context host}
                    
                    After the creation of a dispatch table, the definition of a context host is required. A context host is the union of a dispatch table and a managed host.

                    \paragraph{Actors}
                        \begin{itemize}
                            \item Networking layer developer.
                            \item NetLayer library.
                        \end{itemize}

                     \paragraph{Pre-conditions}
                        \begin{itemize}
                            \item NetLayer was correctly included.
                            \item A dispatch table was created.
                            \item A tunnel type was chosen.
                        \end{itemize}

                    \paragraph{Post-conditions}
                        \begin{itemize}
                            \item An usable context host was defined.
                            \item A previously defined dispatch table is now bound to the context host.
                            \item The context host can now send/receive bound payload types.
                        \end{itemize}

                    \begin{figure}[H]
                    \caption{Defining a context host - use case diagram.}
                    \centering
                    \includegraphics[width=0.65\textwidth]{d/uc/def_context_host.png}
                    \end{figure}


                \subsubsection{Handling incoming payloads}
                    
                    Incoming payloads can be either handled by managed hosts, bypassing the dispatch table, or by context hosts. 
                    Context hosts automatically call a bound function depending on the type of the received payload.

                    \paragraph{Actors}
                        \begin{itemize}
                            \item Networking layer developer.
                            \item Application layer developer.
                            \item NetLayer library.
                        \end{itemize}

                    \paragraph{Pre-conditions}
                        \begin{itemize}
                            \item NetLayer was correctly included.
                            \item A context host was defined.
                            \item Payload types were bound to dispatch table.
                        \end{itemize}

                    \paragraph{Flow of events}
                        \begin{itemize}
                            \item
                        \end{itemize}

                    \paragraph{Post-conditions}
                        \begin{itemize}
                            \item Incoming payloads were handled or an error occurred.
                        \end{itemize}

                    \begin{figure}[H]
                    \caption{Handling incoming payloads - use case diagram.}
                    \centering
                    \includegraphics[width=0.65\textwidth]{d/uc/inc_payloads.png}
                    \end{figure}



                \subsubsection{Handling outgoing payloads}
                    
                    Outgoing packets can be sent both by managed hosts and context hosts. Context hosts provide functionality to mark the type of the packet, so that receivers can handle it thanks to dispatch tables.

                    \paragraph{Actors}
                        \begin{itemize}
                            \item Networking layer developer.
                            \item Application layer developer.
                            \item NetLayer library.
                        \end{itemize}

                    \paragraph{Pre-conditions}
                        \begin{itemize}
                            \item NetLayer was correctly included.
                            \item A context host was defined.
                            \item Payload types were bound to dispatch table.
                        \end{itemize}

                    \paragraph{Post-conditions}
                        \begin{itemize}
                            \item Outgoing payloads were sent or an error occurred.
                        \end{itemize}

                    \begin{figure}[H]
                    \caption{Handling outgoing payloads - use case diagram.}
                    \centering
                    \includegraphics[width=0.65\textwidth]{d/uc/outgoing.png}
                    \end{figure}



            \newpage

            \subsection{Non-functional requirements}
                Functional requirements are supported by \emph{non-functional requirements} (also known as quality requirements), which impose constraints on the design or implementation (such as performance requirements, security, or reliability).

                \subsubsection{Performance}
                    The system will be designed from the ground-up with emphasis on performance. 

                    The layered architecture will allow users to follow the \emph{pay only what you use} principle, which is one of C++'s biggest selling points.

                    NetLayer tries to do as much as possible during compilation, avoiding unnecessary run-time polymorphism overhead.

                \subsubsection{Reliability}
                    The system will have to be reliable and keep working in case of errors.

                    Since NetLayer is a general-purpose library, intended for use in multiple domains, \emph{exceptions are not used} throughout the library. 
                    Real-time simulation and game development industries prefer avoiding using exceptions because they unfortunately always bring a small amount of runtime overhead, even when rarely used throughout the program.

                    NetLayer will allow users to define and use their preferred error handling systems.

                \subsubsection{Security}

                    Encryption and other security features are out of NetLayer's scope - users can implement them on top of the library if necessary.

                \subsubsection{Maintainability and portability}
                    Being an open-source project, \emph{maintainability}, \emph{extensibility} and \emph{portability} are key.

                    The code layer will be carefully designed and organized to allow easy maintenance, bugfixing and feature addition.

                    To ensure maximum portability, the product will be designed to work on the most popular \emph{GNU/Linux} distributions and will be thoroughly tested on different platforms.

        \section{Analysis models}
            \subsection{Activity diagrams}
                Activity diagrams are graphical representations of workflows of stepwise activities and actions with support for choice, iteration and concurrency.
                In the Unified Modeling Language, activity diagrams are intended to model both computational and organisational processes (i.e. workflows).
                Activity diagrams show the overall flow of control.

                \newpage
                The following diagram shows the required steps to define a serializable type.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/def_ser.png}
                \end{figure}



                \newpage
                The following diagram shows the required steps to serialize an object into a payload.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/def_ser_obj.png}
                \end{figure}





                \newpage
                The following diagram shows the required steps to deserialize a payload into an object.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/def_deserialize_obj.png}
                \end{figure}





                \newpage
                The following diagram shows the required steps to define a tunnel.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/def_tunnel.png}
                \end{figure}






                \newpage
                The following diagram shows the required steps to create a managed host.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/def_manhost.png}
                \end{figure}





                \newpage
                The following diagram shows the required steps to create and bind a dispatch table.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/disptable.png}
                \end{figure}





                \newpage
                The following diagram shows the required steps to create a context host.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/conthost.png}
                \end{figure}





                \newpage
                The following diagram shows the required steps to receive a bound payload.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/send_p.png}
                \end{figure}





                \newpage
                The following diagram shows the required steps to send a bound payload.

                \begin{figure}[H]
                %\caption{}
                \centering
                \includegraphics[width=0.7\textwidth]{d/ac/recv_p.png}
                \end{figure}





                \newpage
                \newpage

            \subsection{Class diagrams}

                \emph{Class diagrams} are created using UML.

                The \emph{Unified Modeling Language} (UML) is a general-purpose modeling language in the field of software engineering, which is designed to provide a standard way to visualize the design of a system.

                It offers a way to visualize a system's architectural blueprints in a diagram, including elements such as:

                \begin{itemize}
                    \item Any activities (jobs).
                    \item Individual components of the system.
                    \item And how they can interact with other software components.
                    \item How the system will run.
                    \item How entities interact with others (components and interfaces).
                    \item External user interface.
                \end{itemize}

                \begin{figure}[H]
                \caption{NetLayer complete class diagram.}
                \centering
                \includegraphics[width=0.9\textwidth]{d/coll/src.png}
                \end{figure}

                \newpage

                \begin{figure}[H]
                \caption{Managed buffer collaboration diagram.}
                \centering
                \includegraphics[width=0.4\textwidth]{d/coll/coll_pcktbuf.png}
                \end{figure}

                \newpage

                \begin{figure}[H]
                \caption{Managed host collaboration diagram.}
                \centering
                \includegraphics[width=0.4\textwidth]{d/coll/coll_manhost.png}
                \end{figure}

                \newpage

                \begin{figure}[H]
                \caption{Context host collaboration diagram.}
                \centering
                \includegraphics[width=0.4\textwidth]{d/coll/coll_ctxhost.png}
                \end{figure}

                \newpage

                \begin{figure}[H]
                \caption{Dispatch table collaboration diagram.}
                \centering
                \includegraphics[width=0.4\textwidth]{d/coll/coll_disptab.png}
                \end{figure}

                \newpage                




\part{Technical analysis}
        The following part of the thesis will cover all implementation choices and details for NetLayer in depth.

        Firstly, the \emph{development environment and tools} and \emph{chosen technologies} will be described and motivated.

        Afterwards, the technical details, including code examples and APIs, will be shown for all modules of the library.

        The library is divided in multiple modules:
        \begin{itemize}
            \item \emph{Common}: contains type aliases and dependencies shared by all modules. Also manages API macros and debugging functions.
            \item \emph{Serialization}: provides a generic interface to serialize and deserialize C++ objects. Defines serializaion/deserialization functions for commonly used standard types.
            \item \emph{Payload}: contains the payload abstraction, composed by an address and generic serializable data.
            \item \emph{Tunnel}: contains all the default tunnel abstractions. They are: UDP socket, TCP socket, TCP listener, mock tunnel.
            \item \emph{Architecture}: provides types required to build a network application architecture. Contains managed packet buffers, hosts and auxiliary thread-safe data structures. 
            \item \emph{Pckt}: provides utilities to automatically define serialization/deserialization functions for user-defined types. Also contains convenient functions to initialize, send and receive those structures.
            \item \emph{Bound}: metaprogramming module containing classes and functions to allow compile-time binding and definitions of context hosts.
        \end{itemize}

        \chapter{Development process}

            \section{Environment and tools}
                All modules of NetLayer have been developed on \emph{Arch Linux x64}, a lightweight GNU/Linux distribution.

                Arch is installed as a minimal base system, configured by the user upon which their own ideal environment is assembled by installing only what is required or desired for their unique purposes. GUI configuration utilities are not officially provided, and most system configuration is performed from the shell and a text editor. Based on a rolling-release model, Arch strives to stay bleeding edge, and typically offers the latest stable versions of most software.

                \emph{Qt Creator} was used as the main IDE for the project - it seamlessly integrates \emph{CMake}, the de-facto standard build system for modern C++ projects, speeding up development time significantly.

                To write shell scripts, a modern graphical text editor, \emph{Sublime Text 3}, was used instead.

            \section{Docker}
                Docker is an open-source project that \emph{automates the deployment of applications} inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux.

                Docker uses resource isolation features of the Linux kernel such as \emph{cgroups} and \emph{kernel namespaces} to allow independent containers to run within a single Linux instance.

                This technology has been used since the beginning of the development process to \emph{separate veeForum data and packages} from the host system and to dramatically increase \emph{portability} and \emph{ease of testing}.

                Docker is used for the example projects bundled with NetLayer that require a web server or a database.1

            \section{Version control system}
                Version control systems (VCSs) allow the \emph{management of changes} to documents, computer programs, large web sites, and other collections of information.

                Nowadays, a version control system is \emph{essential} for the development of any project.
                Being able to track changes, develop features in separate \emph{branches}, have multiple programmers work on the same code base without conflicts and much more is extremely important for projects of any scope and size.

                The chosen VCS is \emph{Git}, a distributed revision control system with an emphasis on \emph{speed}, \emph{data integrity}, and support for \emph{distributed, non-linear workflows}.

                Git is widely appreciated in the private and open-source programming communities - it was initially designed and developed by \emph{Linus Torvalds} for Linux kernel development in 2005, and has since become the most widely adopted version control system for software development.

                The veeForum project is \emph{open-source} and \emph{appreciates feedback and contributions}. It is hosted on \emph{GitHub}, a web-based Git repository hosting service, which offers all of the distributed revision control and source code management (SCM) functionality of Git, while adding \emph{additional features} that make collaboration and public contributions easy and accessible.

            \section{Test-driven development}
                The \emph{test-driven development} (TDD) paradigm was used to develop NetLayer and example applications. 

                TDD is a software development process that relies on the repetition of a very short development cycle: first the developer writes an automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.

            \section{Technologies used}
                C++14, which is the latest official C++ standard, released in 2 March 2014 \emph{(paper N3936)}, is the language of choice for NetLayer.
                
                Like C++11, this newer standard is a huge step forward for the language. \emph{Smarter memory managament}, \emph{automatic type deduction}, and countless new programming and metaprogramming features allow developers to write much safer and powerful code.
                C++11 and C++14 features are what make NetLayer possible and its syntax cleaner and easier to use.

                On top of C++14 and its standard library, the \emph{SSV framework} is being used as well. This framework was written completely from scratch by me, \emph{Vittorio Romeo}, and is available under the open-source AFL3.0 license on GitHub.

                The \emph{SSVUtils} library, used throughout the whole program, features many heterogeneous self-contained modules: an efficient and modern handwritten JSON parser, a preprocessor metaprogramming module, a template metaprogramming module, automatic console formatted output for containers and user-defined types, efficient data structures (bimap, handle vector, growable arrays), advanced memory management facilities, type-safe variadic unions, handwritten templating system, filesystem management, easy benchmarking of portions of code, and much more.

                An additional dependencies for NetLayer is the \emph{SFML} library, which offers lightweight abstraction over sockets and packets.

            \section{Thesis}
                The current document was written using \LaTeX{}, an high-quality typesetting system; it includes features designed for the production of \emph{technical and scientific documentation}.

                \LaTeX{} was chosen for the current document because of the visually pleasant typography, its extensibility features and its abilities to include and highlight source code.

                \subsection{LatexPP}
                    A small \emph{C++14} \LaTeX{} preprocessor named \emph{LatexPP} was developed for the composition of this thesis.

                    LatexPP allows to use an intuitive syntax that avoids markup repetition for code highlighting and macros.

                    Preprocessing and compiling a \LaTeX{} document using LatexPP is simple and can be automated using a simple \emph{bash} script.


\begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm, fontsize=\footnotesize]{bash}
    #!/bin/bash

    latexpp ./thesis.lpp > ./thesis.tex
    pdflatex -shell-escape ./thesis.tex && chromium ./thesis.pdf
\end{minted}

                    LatexPP is available as an open-source project on GitHub:

                    \url{https://github.com/SuperV1234/latexpp}

                \subsection{PlantUML}
                    \emph{PlantUML} is a software that allows easy creation of UML diagrams from a simple language. It was used to create activity diagrams and use case diagrams.

                \subsection{Doxygen}
                    \emph{Doxygen} is the de facto standard tool for generating documentation from annotated C++ sources. It automatically generates well-formatted and complete documentation pages for classes, namespaces and functions. Thanks to \emph{Graphviz} integration, it also automatically generates class and collaboration diagrams.

\chapter{Library structure}

    \begin{figure}[!htb]
    \caption{NetLayer modules.}
    \centering
    \includegraphics[width=0.85\textwidth]{inc/0.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{NetLayer module dependencies.}
    \centering
    \includegraphics[width=0.75\textwidth]{inc/deps.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Serialization dependency graph.}
    \centering
    \includegraphics[width=0.9\textwidth]{inc/dep_ser.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Tunnel dependency graph.}
    \centering
    \includegraphics[width=1\textwidth]{inc/dep_tunnel.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Payload dependency graph.}
    \centering
    \includegraphics[width=1\textwidth]{inc/dep_paylod.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Packet types dependency graph.}
    \centering
    \includegraphics[width=0.95\textwidth]{inc/dep_pckt.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Architecture dependency graph.}
    \centering
    \includegraphics[width=1\textwidth]{inc/dep_archi.png}
    \end{figure}

\chapter{Class documentation}
    \input{d5/db9/classnl_1_1impl_1_1busy__loop}
    \input{de/d57/classexperiment_1_1ContextHost}
    \input{db/d90/classexperiment_1_1DispatchTable}
    \input{d3/db6/classnl_1_1ManagedHostImpl}
    \input{df/dda/classnl_1_1impl_1_1ManagedPcktBuf}
    \input{de/d06/classnl_1_1impl_1_1ManagedRecvBuf}
    \input{d7/dca/classnl_1_1impl_1_1ManagedSendBuf}
    \input{db/dc7/structnl_1_1PAddress}
    \input{d4/d26/structnl_1_1Payload}
    \input{df/da7/structnl_1_1impl_1_1Pckt}
    \input{da/d3d/classnl_1_1impl_1_1ThreadSafeQueue}
    \input{d5/dbb/classnl_1_1impl_1_1Tunnel_1_1UDPSckt}



%%% TODO %%% 

\part{Conclusion}
    \chapter{Learning experience}

        Creating the \emph{veeForum} framework was an incredible learning experience. Many new technologies had to be used and integrated in the project to achieve a satisfactory final result.

        \begin{itemize}
            \item \emph{Planning and design}: using Software Engineering guidelines and design processes was extremely educational and contributed to the quality of the project.
            \item \emph{GNU/Linux containers}: using Docker containers for the database and the web application was beneficial in understanding the advantages of containers and allowed a decoupled and highly portable final result.
            \item \emph{\LaTeX{} and LatexPP}: using \LaTeX{} and writing a simple preprocessor for it was a very education thesis-writing and typesetting experience and definitely resulted in a high-quality document.
            \item \emph{Complex database design}: having to deal with 20+ tables, 30+ triggers and 15+ stored procedures for the correct functioning of the system was a very educational experience in complex SQL coding and database design practices. Making everything work toghether, safely and efficiently, required learning complex SQL constructs such as \emph{cursors} and \emph{imperative loops} and spending a lot of time on table/relationship design beforehand.
            \item \emph{Complex PHP framework}: having two feature-rich PHP modules that needed to conveniently expose functionality to communicate with the database to the developer was a great learning experience in \emph{object-oriented development} and \emph{library design}. Generating HTML using polymorphic PHP class hierarchies was also extremely beneficial in the understanding of dynamic HTML page generation processes and tree-like syntactic structures.
        \end{itemize}

    \chapter{Future}
        
        \emph{veeForum} can be greatly improved, and will probably be expanded upon and used as the forum framework for some future projects.

            Here are some possible improvements:

            \begin{itemize}
                \item \emph{Theming and customization}: add theming capabilities and user-friendly graphical customization options to the default web application.
                \item \emph{Private messaging}: add synchronous and asynchronous private messaging capabilities between users (and/or groups), along with new permissions and privileges.
                \item \emph{RSS feed}: add the possibility to subscribe to sections/threads/users and receive an RSS feed.
                \item \emph{Public JSON API}: add a public RESTful JSON API that can be used to retrieve the forum contents and display them in custom clients.
                \item \emph{Personal user profiles}: add personal user profile customization options, such as avatars, biographies, interests, contact information, etc...
                \item \emph{Email notifications}: allow users to receive notification alerts as emails.
                \item \emph{Dashboard}: add a dashboard displaying the most popular threads and users in the main page.
                \item \emph{Real-time statistics}: show the real-time number of users viewing a particular section or thread directly in the web interface.
                \item \emph{Mailing list support}: add a mailing bot that can be used to interact with the forum contents directly from the user's favorite email client.
            \end{itemize}



%%% TODO %%% 

\part{Example application: NLBroadcast}
    
    \chapter{Project specifications}    

        \section{Client request}
            The client requests a command-line persistent chat application, allowing users to register, login, create channels and broadcast messages.
            The application should be able to run both in server mode and client mode. 

            The messages must be saved and users must be able to retrieve them by specifying a date range.

            Users registered to the system can subscribe to any number of channels. When users are logged in, and a message is broadcasted to one of the channels they're subscribed to, they must receive a notification with the broadcast content.

        \section{Scope}

                \subsection{Identity}
                    The software that will be designed and produced will be called \emph{NLBroadcast}.

                \subsection{Feature extents}

                    The complete product will:

                    \begin{itemize}
                        \item Allow users to deploy and run a server with the following capabilities:

                            \begin{itemize}
                                \item Manage user credentials.
                                \item Listen to incoming broadcasts and send notifications to users.
                            \end{itemize}

                        \item Allow users to connect to an existing server to perform the following actions:
                            \begin{itemize}
                                \item Registration to the server.
                                \item Login and logout.
                                \item Create and delete channels.
                                \item Subscribe and unsubscribe from channels.
                                \item Send broadcasts to channels.
                                \item Retrieve broadcast from channels in a specific date range.
                            \end{itemize}

                    \end{itemize}

        \section{Glossary}

            \begin{itemize}
                \item \emph{User}: registered user to a NLBroadcast server. Has an associated username and password.
                \item \emph{Channel}: possible target for broadcast messages. Can be created and removed by users. Users can subscribe and unsubscribe to channels.
                \item \emph{Broadcast}: text-based message that can target a specific channel. To send a broadcast to a specific channel, users must be subscribed to it.
            \end{itemize}

    \chapter{Technical analysis}

        \section{Dependencies}

            The completed product will depend on \emph{NetLayer} and \emph{sqlpp11}. The sqlpp11 library is an open-source project that allows developers to use a type-safe embedded C++ domain specific language for SQL queries.

            \emph{MariaDB}, a modern drop-in replacement for MySQL is used as the DBMS. 

            MariaDB is fully compliant with the MySQL standard and language, but it is more performant and has additional features. It is the default DBMS in the Arch Linux distribution.

            By default, MariaDB uses the \emph{XtraDB} storage engine, a performance enhanced fork of the InnoDB storage engine.

            Percona XtraDB includes all of InnoDB's robust, reliable ACID-compliant design and advanced MVCC architecture, and builds on that solid foundation with more features, more tunability, more metrics, and more scalability. In particular, it is designed to scale better on many cores, to use memory more efficiently, and to be more convenient and useful. 

            To connect \emph{sqlpp11} to \emph{MariaDB}, the additional small \emph{sqlpp11-connector-mysql} library will be used.
        
        \section{Namespace Documentation}
            \input{dd/df0/namespacedb__actions}
            \input{de/d05/namespacedb__actions_1_1impl}
            \input{d3/daf/namespaceexample}
            \input{d0/d20/namespaceexample_1_1to__c}
            \input{d0/d4e/namespaceexample_1_1to__s}

        \section{Class Documentation}
            \input{dc/d3a/structexample_1_1client__state}
            \input{d2/dd2/classexample_1_1connection__state}
            \input{d0/d71/classexample_1_1server__state}

        \section{File Documentation}
            \input{df/d0a/main_8cpp}
        
        \section{Screenshots}




%%% TODO %%% 

\part{References}
   
        
        Listed below are the references used during the development of \emph{veeForum} and the writing of this thesis.

        \begin{itemize}
            \item veeForum GitHub repository: \url{https://github.com/SuperV1234/veeForum}
            \item LatexPP GitHub repository: \url{https://github.com/SuperV1234/Experiments}
            \item UNIME website: \url{http://unime.it}
            \item My personal website: \url{https://vittorioromeo.info}

            \item ShareLaTeX learn: \url{https://www.sharelatex.com/learn}
            \item Wikipedia - Software engineering: \url{http://en.wikipedia.org/wiki/Software_engineering}
            \item Software engineering vs Programming: \url{http://www.ics.uci.edu/~ziv/ooad/intro_to_se/tsld008.htm}
            \item IEEE SRS guidelines: \url{home.agh.edu.pl/~jsw/io/IEEE830.doc}
            \item MariaDB documentation: \url{https://mariadb.org/docs/}
            \item PHP documentation: \url{http://php.net/docs.php}
        
            \item Git documentation: \url{https://git-scm.com/documentation}
            \item Docker documentation: \url{https://docs.docker.com/}
            \item GitHub: \url{https://github.com/}
            \item Arch Linux wiki: \url{https://wiki.archlinux.org/}
        \end{itemize}





\end{document}




