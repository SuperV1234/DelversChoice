\part{Technical analysis}
        The following part of the thesis will cover all implementation choices and details for NetLayer in depth.

        Firstly, the \emph{development environment and tools} and \emph{chosen technologies} will be described and motivated.

        Afterwards, the technical details, including code examples and APIs, will be shown for all modules of the library.

        The library is divided in multiple modules:
        \begin{itemize}
            \item \emph{Common}: contains type aliases and dependencies shared by all modules. Also manages API macros and debugging functions.
            \item \emph{Serialization}: provides a generic interface to serialize and deserialize C++ objects. Defines serializaion/deserialization functions for commonly used standard types.
            \item \emph{Payload}: contains the payload abstraction, composed by an address and generic serializable data.
            \item \emph{Tunnel}: contains all the default tunnel abstractions. They are: UDP socket, TCP socket, TCP listener, mock tunnel.
            \item \emph{Architecture}: provides types required to build a network application architecture. Contains managed packet buffers, hosts and auxiliary thread-safe data structures. 
            \item \emph{Pckt}: provides utilities to automatically define serialization/deserialization functions for user-defined types. Also contains convenient functions to initialize, send and receive those structures.
            \item \emph{Bound}: metaprogramming module containing classes and functions to allow compile-time binding and definitions of context hosts.
        \end{itemize}

        \chapter{Development process}

            \section{Environment and tools}
                All modules of NetLayer have been developed on \emph{Arch Linux x64}, a lightweight GNU/Linux distribution.

                Arch is installed as a minimal base system, configured by the user upon which their own ideal environment is assembled by installing only what is required or desired for their unique purposes. GUI configuration utilities are not officially provided, and most system configuration is performed from the shell and a text editor. Based on a rolling-release model, Arch strives to stay bleeding edge, and typically offers the latest stable versions of most software.

                \emph{Qt Creator} was used as the main IDE for the project - it seamlessly integrates \emph{CMake}, the de-facto standard build system for modern C++ projects, speeding up development time significantly.

                To write shell scripts, a modern graphical text editor, \emph{Sublime Text 3}, was used instead.

            \section{Docker}
                Docker is an open-source project that \emph{automates the deployment of applications} inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux.

                Docker uses resource isolation features of the Linux kernel such as \emph{cgroups} and \emph{kernel namespaces} to allow independent containers to run within a single Linux instance.

                This technology has been used since the beginning of the development process to \emph{separate veeForum data and packages} from the host system and to dramatically increase \emph{portability} and \emph{ease of testing}.

                Docker is used for the example projects bundled with NetLayer that require a web server or a database.1

            \section{Version control system}
                Version control systems (VCSs) allow the \emph{management of changes} to documents, computer programs, large web sites, and other collections of information.

                Nowadays, a version control system is \emph{essential} for the development of any project.
                Being able to track changes, develop features in separate \emph{branches}, have multiple programmers work on the same code base without conflicts and much more is extremely important for projects of any scope and size.

                The chosen VCS is \emph{Git}, a distributed revision control system with an emphasis on \emph{speed}, \emph{data integrity}, and support for \emph{distributed, non-linear workflows}.

                Git is widely appreciated in the private and open-source programming communities - it was initially designed and developed by \emph{Linus Torvalds} for Linux kernel development in 2005, and has since become the most widely adopted version control system for software development.

                The veeForum project is \emph{open-source} and \emph{appreciates feedback and contributions}. It is hosted on \emph{GitHub}, a web-based Git repository hosting service, which offers all of the distributed revision control and source code management (SCM) functionality of Git, while adding \emph{additional features} that make collaboration and public contributions easy and accessible.

            \section{Test-driven development}
                The \emph{test-driven development} (TDD) paradigm was used to develop NetLayer and example applications. 

                TDD is a software development process that relies on the repetition of a very short development cycle: first the developer writes an automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.

            \section{Technologies used}
                C++14, which is the latest official C++ standard, released in 2 March 2014 \emph{(paper N3936)}, is the language of choice for NetLayer.
                
                Like C++11, this newer standard is a huge step forward for the language. \emph{Smarter memory managament}, \emph{automatic type deduction}, and countless new programming and metaprogramming features allow developers to write much safer and powerful code.
                C++11 and C++14 features are what make NetLayer possible and its syntax cleaner and easier to use.

                On top of C++14 and its standard library, the \emph{SSV framework} is being used as well. This framework was written completely from scratch by me, \emph{Vittorio Romeo}, and is available under the open-source AFL3.0 license on GitHub.

                The \emph{SSVUtils} library, used throughout the whole program, features many heterogeneous self-contained modules: an efficient and modern handwritten JSON parser, a preprocessor metaprogramming module, a template metaprogramming module, automatic console formatted output for containers and user-defined types, efficient data structures (bimap, handle vector, growable arrays), advanced memory management facilities, type-safe variadic unions, handwritten templating system, filesystem management, easy benchmarking of portions of code, and much more.

                An additional dependencies for NetLayer is the \emph{SFML} library, which offers lightweight abstraction over sockets and packets.

            \section{Thesis}
                The current document was written using \LaTeX{}, an high-quality typesetting system; it includes features designed for the production of \emph{technical and scientific documentation}.

                \LaTeX{} was chosen for the current document because of the visually pleasant typography, its extensibility features and its abilities to include and highlight source code.

                \subsection{LatexPP}
                    A small \emph{C++14} \LaTeX{} preprocessor named \emph{LatexPP} was developed for the composition of this thesis.

                    LatexPP allows to use an intuitive syntax that avoids markup repetition for code highlighting and macros.

                    Preprocessing and compiling a \LaTeX{} document using LatexPP is simple and can be automated using a simple \emph{bash} script.


!!(bash)
!!{
    #!/bin/bash

    latexpp ./thesis.lpp > ./thesis.tex
    pdflatex -shell-escape ./thesis.tex && chromium ./thesis.pdf
!!}

                    LatexPP is available as an open-source project on GitHub:

                    \url{https://github.com/SuperV1234/latexpp}

                \subsection{PlantUML}
                    \emph{PlantUML} is a software that allows easy creation of UML diagrams from a simple language. It was used to create activity diagrams and use case diagrams.

                \subsection{Doxygen}
                    \emph{Doxygen} is the de facto standard tool for generating documentation from annotated C++ sources. It automatically generates well-formatted and complete documentation pages for classes, namespaces and functions. Thanks to \emph{Graphviz} integration, it also automatically generates class and collaboration diagrams.

\chapter{Library structure}

    \begin{figure}[!htb]
    \caption{NetLayer modules.}
    \centering
    \includegraphics[width=0.85\textwidth]{inc/0.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{NetLayer module dependencies.}
    \centering
    \includegraphics[width=0.75\textwidth]{inc/deps.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Serialization dependency graph.}
    \centering
    \includegraphics[width=0.9\textwidth]{inc/dep_ser.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Tunnel dependency graph.}
    \centering
    \includegraphics[width=1\textwidth]{inc/dep_tunnel.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Payload dependency graph.}
    \centering
    \includegraphics[width=1\textwidth]{inc/dep_paylod.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Packet types dependency graph.}
    \centering
    \includegraphics[width=0.95\textwidth]{inc/dep_pckt.png}
    \end{figure}

    \begin{figure}[!htb]
    \caption{Architecture dependency graph.}
    \centering
    \includegraphics[width=1\textwidth]{inc/dep_archi.png}
    \end{figure}

\chapter{Class documentation}
    \input{d5/db9/classnl_1_1impl_1_1busy__loop}
    \input{de/d57/classexperiment_1_1ContextHost}
    \input{db/d90/classexperiment_1_1DispatchTable}
    \input{d3/db6/classnl_1_1ManagedHostImpl}
    \input{df/dda/classnl_1_1impl_1_1ManagedPcktBuf}
    \input{de/d06/classnl_1_1impl_1_1ManagedRecvBuf}
    \input{d7/dca/classnl_1_1impl_1_1ManagedSendBuf}
    \input{db/dc7/structnl_1_1PAddress}
    \input{d4/d26/structnl_1_1Payload}
    \input{df/da7/structnl_1_1impl_1_1Pckt}
    \input{da/d3d/classnl_1_1impl_1_1ThreadSafeQueue}
    \input{d5/dbb/classnl_1_1impl_1_1Tunnel_1_1UDPSckt}